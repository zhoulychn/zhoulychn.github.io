<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>二叉树最大路径和</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="gwkv" id="二叉树最大路径和">二叉树最大路径和</h1><p data-anchor-id="b3cr"><code>数据结构与算法</code></p><p data-anchor-id="f2sx"><a href="http://zhoulychn.github.io/algorithm/center.html" target="_blank">点击返回导航页</a></p><hr><div class="md-section-divider"></div><h2 data-anchor-id="3477" id="问题描述">问题描述</h2><p data-anchor-id="he88">给出一棵二叉树，寻找一条路径使其路径和最大，路径可以在任一节点中开始和结束（路径和为两个节点之间所在路径上的节点权值之和）。</p><div class="md-section-divider"></div><h2 data-anchor-id="ez1i" id="算法思路">算法思路</h2><p data-anchor-id="zny2">利用递归函数，得到左右结点的最大路径权值，加上根节点权值，判断是否比当前权值和大，如果更大就重置，然后返回以本次调用为根节点的单路径最大和。</p><p data-anchor-id="zkz8">全部的路径和，在递归中处理，</p><div class="md-section-divider"></div><h2 data-anchor-id="3aib" id="代码实现">代码实现</h2><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="zt1k"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> max </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">.</span><span class="pln">MIN_VALUE</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> maxPathSum</span><span class="pun">(</span><span class="typ">TreeNode</span><span class="pln"> root</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">    helper</span><span class="pun">(</span><span class="pln">root</span><span class="pun">);</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> max</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pun">}</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> helper</span><span class="pun">(</span><span class="typ">TreeNode</span><span class="pln"> root</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="com">//递归获取分别以左、右结点向下的最大路径</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> left </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">root</span><span class="pun">.</span><span class="pln">left </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> helper</span><span class="pun">(</span><span class="pln">root</span><span class="pun">.</span><span class="pln">left</span><span class="pun">));</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> right </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">root</span><span class="pun">.</span><span class="pln">right </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> helper</span><span class="pun">(</span><span class="pln">root</span><span class="pun">.</span><span class="pln">right</span><span class="pun">));</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="com">//判断该结点与左右结点是否构成最大路径，是则重置最大权值。</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> sum </span><span class="pun">=</span><span class="pln"> left </span><span class="pun">+</span><span class="pln"> right </span><span class="pun">+</span><span class="pln"> root</span><span class="pun">.</span><span class="pln">val</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">    max </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sum </span><span class="pun">&gt;</span><span class="pln"> max </span><span class="pun">?</span><span class="pln"> sum </span><span class="pun">:</span><span class="pln"> max</span><span class="pun">);</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="com">//判断左右那边权值更大，更大</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> val </span><span class="pun">=</span><span class="pln"> root</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">left </span><span class="pun">&gt;</span><span class="pln"> right </span><span class="pun">?</span><span class="pln"> left </span><span class="pun">:</span><span class="pln"> right</span><span class="pun">);</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> val </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> val </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pun">}</span></code></li></ol></pre></div>
</body>
</html>