<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>搜索旋转排序数组</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="vh4p" id="搜索旋转排序数组">搜索旋转排序数组</h1><p data-anchor-id="vxqh"><code>数据结构与算法</code></p><p data-anchor-id="rwvp"><a href="http://zhoulychn.github.io/algorithm/center.html" target="_blank">点击返回导航页</a></p><hr><div class="md-section-divider"></div><h2 data-anchor-id="ngpb" id="问题描述">问题描述</h2><p data-anchor-id="3fyb">假设有一个排序的按未知的旋转轴旋转的数组(比如，0 1 2 4 5 6 7 可能成为4 5 6 7 0 1 2)。查找数组元素的最小值并返回。</p><p data-anchor-id="axgm">你可以假设数组中不存在重复的元素。</p><div class="md-section-divider"></div><h2 data-anchor-id="buib" id="算法思路">算法思路</h2><p data-anchor-id="jbkw">本题可以直接扫描一遍找出最小值，但是就没有用上旋转数组的特性了，如果用二分查找复杂度就更低了，旋转数组的特性，可以切分为两段升序子数组，并且第一段的第一个元素，大于第二段的最后一个元素，最小值就在第二段元素的开头位置，利用这些性质，调整二分查找的索引位置就行了。</p><div class="md-section-divider"></div><h2 data-anchor-id="76su" id="代码实现">代码实现</h2><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ntwj"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> searchMin</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">[]</span><span class="pln"> A</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="com">//数组只有一个元素，就是最小值。</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">A</span><span class="pun">.</span><span class="pln">length </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> A</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span></code></li><li class="L4"><code class="language-java"></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="com">//设置索引low和high</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> low </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> high </span><span class="pun">=</span><span class="pln"> A</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="com">//数据正常的情况下，比有结果。</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-java"></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="pun">如果</span><span class="pln">low</span><span class="pun">和</span><span class="pln">high</span><span class="pun">中间只有一个元素，则必为最小值</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">high </span><span class="pun">-</span><span class="pln"> low </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> A</span><span class="pun">[</span><span class="pln">high</span><span class="pun">];</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> mid </span><span class="pun">=</span><span class="pln"> low </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">high </span><span class="pun">-</span><span class="pln"> low</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> pivot </span><span class="pun">=</span><span class="pln"> A</span><span class="pun">[</span><span class="pln">mid</span><span class="pun">];</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="com">//mid元素大于第二段的最大值，说明mid在第一段，需要右移一位。</span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pivot </span><span class="pun">&gt;</span><span class="pln"> A</span><span class="pun">[</span><span class="pln">high</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code class="language-java"><span class="pln">            low </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L0"><code class="language-java"><span class="pln">            </span><span class="kwd">continue</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L2"><code class="language-java"></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="com">//此时mid小于第二段的最大值，说明位于第二段中，如果此元素也小于左边元素，则为最小值</span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pivot </span><span class="pun">&lt;</span><span class="pln"> A</span><span class="pun">[</span><span class="pln">mid </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">])</span></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> pivot</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="com">//在第二段中间，high左移一位</span></code></li><li class="L8"><code class="language-java"><span class="pln">        high </span><span class="pun">=</span><span class="pln"> mid </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L0"><code class="language-java"><span class="pun">}</span></code></li></ol></pre></div>
</body>
</html>