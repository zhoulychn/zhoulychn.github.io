<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>ArrayList</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="u0d2" id="arraylist">ArrayList</h1><p data-anchor-id="dluh"><code>集合</code></p><hr><p data-anchor-id="hvlc"><div class="toc"><div class="toc">
<ul>
<li><a href="#arraylist">ArrayList</a><ul>
<li><a href="#结构基础">结构基础</a></li>
<li><a href="#get">get()</a></li>
<li><a href="#set">set()</a></li>
<li><a href="#add">add()</a></li>
<li><a href="#addall">addAll()</a></li>
<li><a href="#remove">remove()</a></li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="ur2n" id="结构基础">结构基础</h2><p data-anchor-id="17ta">ArrayList实现List接口,RandomAccess(表示提供随机访问),Cloneable,Serializable，默认容量为10。</p><ol data-anchor-id="7ka7">
<li>元素按照插入顺序排序。</li>
<li>允许放入null。</li>
<li>底层通过Object数组实现。</li>
<li>容器有容量capacity属性，容量不足时容器会扩容。</li>
</ol><div class="md-section-divider"></div><h2 data-anchor-id="8m3r" id="get">get()</h2><p data-anchor-id="zqgg">直接通过位置找到元素，泛型强转后返回。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="g13j"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> E get</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> index</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    rangeCheck</span><span class="pun">(</span><span class="pln">index</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> elementData</span><span class="pun">(</span><span class="pln">index</span><span class="pun">);</span></code></li><li class="L4"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="q9h7" id="set">set()</h2><p data-anchor-id="06l8">通过索引找到元素，直接赋值，然后返回旧值。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="lkw4"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> E set</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> index</span><span class="pun">,</span><span class="pln"> E element</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    rangeCheck</span><span class="pun">(</span><span class="pln">index</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"></code></li><li class="L3"><code class="language-java"><span class="pln">    E oldValue </span><span class="pun">=</span><span class="pln"> elementData</span><span class="pun">(</span><span class="pln">index</span><span class="pun">);</span></code></li><li class="L4"><code class="language-java"><span class="pln">    elementData</span><span class="pun">[</span><span class="pln">index</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> element</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> oldValue</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="m83f" id="add">add()</h2><p data-anchor-id="ktqc">判断空间是否够用，不够用直接扩容。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="8fsx"><ol class="linenums"><li class="L0"><code class="language-java"><span class="com">//扩容策略</span></code></li><li class="L1"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> grow</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> minCapacity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="com">// overflow-conscious code</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> oldCapacity </span><span class="pun">=</span><span class="pln"> elementData</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="com">//扩容1.5倍</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> newCapacity </span><span class="pun">=</span><span class="pln"> oldCapacity </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldCapacity </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="com">//容量还是不足，直接等于新容量</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newCapacity </span><span class="pun">-</span><span class="pln"> minCapacity </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L0"><code class="language-java"><span class="pln">        newCapacity </span><span class="pun">=</span><span class="pln"> minCapacity</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="com">//最大容量</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newCapacity </span><span class="pun">-</span><span class="pln"> MAX_ARRAY_SIZE </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L4"><code class="language-java"><span class="pln">        newCapacity </span><span class="pun">=</span><span class="pln"> hugeCapacity</span><span class="pun">(</span><span class="pln">minCapacity</span><span class="pun">);</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="com">// minCapacity is usually close to size, so this is a win:</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="com">//复制到新扩容的数组</span></code></li><li class="L8"><code class="language-java"><span class="pln">    elementData </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Arrays</span><span class="pun">.</span><span class="pln">copyOf</span><span class="pun">(</span><span class="pln">elementData</span><span class="pun">,</span><span class="pln"> newCapacity</span><span class="pun">);</span></code></li><li class="L9"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="7kim" id="addall">addAll()</h2><p data-anchor-id="ill8">跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。</p><div class="md-section-divider"></div><h2 data-anchor-id="phne" id="remove">remove()</h2><p data-anchor-id="487t">remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</p></div>
</body>
</html>