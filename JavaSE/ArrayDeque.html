<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>ArrayDeque</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="bbjm" id="arraydeque">ArrayDeque</h1><p data-anchor-id="13hp"><code>集合</code></p><hr><p data-anchor-id="69h3"><div class="toc"><div class="toc">
<ul>
<li><a href="#arraydeque">ArrayDeque</a><ul>
<li><a href="#基本结构">基本结构</a></li>
<li><a href="#addfirst">addFirst()</a></li>
<li><a href="#addlast">addLast()</a></li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="pq9e" id="基本结构">基本结构</h2><p data-anchor-id="cr4g">ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（CircularArray），也就是说数组的任何一点都可能被看作起点或者终点。head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。</p><p data-anchor-id="fmik">插入头部，head左移；插入尾部，tail右移； <br>
删除头部，head右移；删除尾部，tail左移；</p><p data-anchor-id="sm29">插入是反向的，交汇则一定是空间满了。</p><p data-anchor-id="cyv2">(head - 1) &amp; (length - 1)解决移动到头。 <br>
(tail + 1) &amp; (elements.length - 1)是长度取余，当tail+1=length时，取余为零如果头部也在零则扩容。</p><p data-anchor-id="mxbw">扩容，因为head右边是最先的元素，tail左边是最后的元素。</p><p data-anchor-id="39kr">扩容是将head右边-&gt;数组尾部和数组头部-&gt;tail重新按顺序排列到一个新容器中。</p><p data-anchor-id="cs6g"><img src="http://static.zybuluo.com/zy380104192/vu98mcpzcrg2s3lwigpqn71n/image_1b9qu3u7b14o21su11secdp54jc9.png" alt="image_1b9qu3u7b14o21su11secdp54jc9.png-49.7kB"></p><div class="md-section-divider"></div><h2 data-anchor-id="07o1" id="addfirst">addFirst()</h2><p data-anchor-id="k9m2">addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e即可。</p><p data-anchor-id="4elv"><img src="http://static.zybuluo.com/zy380104192/e2nb86658zml2ssexpprnp0t/image_1b9sjb03f1uq875r1frrdpf1h709.png" alt="image_1b9sjb03f1uq875r1frrdpf1h709.png-16.6kB" title=""></p><p data-anchor-id="b6hs">下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="70nq"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> addFirst</span><span class="pun">(</span><span class="pln">E e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">NullPointerException</span><span class="pun">();</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="com">//head-1为正数，结果head-1；负数，结果elements.length-1(数组末尾)</span></code></li><li class="L4"><code class="language-java"><span class="pln">    elements</span><span class="pun">[</span><span class="pln">head </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">head </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">elements</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">head </span><span class="pun">==</span><span class="pln"> tail</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">        doubleCapacity</span><span class="pun">();</span></code></li><li class="L7"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="0b9q">上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p data-anchor-id="27i5">下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示： <br>
<img src="http://static.zybuluo.com/zy380104192/d4mziyixmxals82v4w6gux38/image_1b9sjej1m17k014ea33719iucucm.png" alt="image_1b9sjej1m17k014ea33719iucucm.png-22.9kB"></p><p data-anchor-id="kd5u">图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="mux7"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> doubleCapacity</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">assert</span><span class="pln"> head </span><span class="pun">==</span><span class="pln"> tail</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> head</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> elements</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> p</span><span class="pun">;</span><span class="pln"> </span><span class="com">// number of elements to the right of p</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> newCapacity </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newCapacity </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IllegalStateException</span><span class="pun">(</span><span class="str">"Sorry, deque too big"</span><span class="pun">);</span></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="typ">Object</span><span class="pun">[]</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">[</span><span class="pln">newCapacity</span><span class="pun">];</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="typ">System</span><span class="pun">.</span><span class="pln">arraycopy</span><span class="pun">(</span><span class="pln">elements</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">);</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="typ">System</span><span class="pun">.</span><span class="pln">arraycopy</span><span class="pun">(</span><span class="pln">elements</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">);</span></code></li><li class="L1"><code class="language-java"><span class="pln">    elements </span><span class="pun">=</span><span class="pln"> a</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    head </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">    tail </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="4s9h" id="addlast">addLast()</h2><p data-anchor-id="1qrn">addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail]=e即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ther"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> addLast</span><span class="pun">(</span><span class="pln">E e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">NullPointerException</span><span class="pun">();</span></code></li><li class="L3"><code class="language-java"><span class="pln">    elements</span><span class="pun">[</span><span class="pln">tail</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tail </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tail </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">elements</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">))</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> head</span><span class="pun">)</span></code></li><li class="L5"><code class="language-java"><span class="pln">        doubleCapacity</span><span class="pun">();</span></code></li><li class="L6"><code class="language-java"><span class="pun">}</span></code></li></ol></pre></div>
</body>
</html>