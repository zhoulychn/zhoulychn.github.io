<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>HashMap</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="rjqg" id="hashmap">HashMap</h1><p data-anchor-id="zlav"><code>集合</code></p><p data-anchor-id="eskc"><a href="http://blog.zhoulychn.com/JavaSE/center.html" target="_blank">点击返回导航页</a></p><hr><p data-anchor-id="jfoe"><div class="toc"><div class="toc">
<ul>
<li><a href="#hashmap">HashMap</a><ul>
<li><a href="#基础结构">基础结构</a></li>
<li><a href="#1-hash">(1) hash</a></li>
<li><a href="#2-getnode">(2) getNode</a></li>
<li><a href="#3-put">(3) put</a></li>
<li><a href="#4-resize">(4) resize</a></li>
<li><a href="#5-remove">(5) remove</a></li>
<li><a href="#6-clear">(6) clear</a></li>
<li><a href="#7-containsvalue">(7) containsValue</a></li>
<li><a href="#8-keyset">(8) keySet</a></li>
<li><a href="#9-replace">(9) replace</a></li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="r4q5" id="基础结构">基础结构</h2><p data-anchor-id="wkie"><strong>存储结构</strong>: <br>
<img src="http://static.zybuluo.com/zy380104192/1347stdf4f0wkzxxxvd8pqm3/image_1c7u1hbak17dvts51p4b1788blt1t.png" alt="image_1c7u1hbak17dvts51p4b1788blt1t.png-43.3kB" title=""></p><p data-anchor-id="pafb"><strong>继承结构</strong>: <br>
<img src="http://static.zybuluo.com/zy380104192/3jp1o0lbwgw3y3bz5gk0xs59/image_1c7tvbh421tp3bg5q1419101a6jm.png" alt="image_1c7tvbh421tp3bg5q1419101a6jm.png-10.9kB" title=""></p><p data-anchor-id="xbmh">HashMap应该算是数据结构中最经典的设计了，使用非常高效，时间复杂度接近与O(n)。</p><p data-anchor-id="jimj">内部是通过一个数组(bucket)来存储的，数组元素是一个保存键值对数据的对象Entry。通过计算key的hash值来判断元素应该放在哪个位置上。</p><p data-anchor-id="um2n">Hash碰撞：key的hash值相同时，会将这个键值对链接起来，取出时通过key的equals方法判断具体想要的元素。</p><p data-anchor-id="djxa">Resize：HashMap会有一个装载因子，每当元素数量超过<code>loadFactor * capacity</code>时，进行扩容。</p><p data-anchor-id="gswk">PS：当bucket的一个位置上冲突超过8时，链表会转为红黑树结构，保证查找的效率。</p><p data-anchor-id="ofwf">下面是HashMap内部一些重要的属性:</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="tv2w"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;[]</span><span class="pln"> table</span><span class="pun">;</span><span class="pln">  </span><span class="com">//bucket，长度限定为2次幂数</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="typ">Map</span><span class="pun">.</span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;&gt;</span><span class="pln"> entrySet</span><span class="pun">;</span><span class="pln">  </span><span class="com">//键值对集合</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> size</span><span class="pun">;</span><span class="pln">  </span><span class="com">//元素个数</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> modCount</span><span class="pun">;</span><span class="pln">  </span><span class="com">//修改次数</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="kwd">int</span><span class="pln"> threshold</span><span class="pun">;</span><span class="pln">  </span><span class="com">//resize的阀值</span></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="kwd">final</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> loadFactor</span><span class="pun">;</span><span class="pln">  </span><span class="com">//扩容因子</span></code></li></ol></pre><p data-anchor-id="x4f0">Entry的构造:</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="4xnj"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">.</span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">;</span><span class="pln">  </span><span class="com">//hash值</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">final</span><span class="pln"> K key</span><span class="pun">;</span><span class="pln">  </span></code></li><li class="L3"><code class="language-java"><span class="pln">    V value</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> next</span><span class="pun">;</span><span class="pln">  </span><span class="com">//链地址法，链接下一个hash值相同的键值对</span></code></li><li class="L5"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="h0hv" id="1-hash">(1) hash</h2><p data-anchor-id="xq2m">hash方法时对key进行hash值的计算，其实这个值本该由其对象本身的hashcode方法决定，不过由于hash值过于重要，在数据量大的时候尤为明显，hash函数的设计应该尽量减少冲突。API作者专门设计了一套hash函数。</p><p data-anchor-id="0yxv">将key的hash码无符号右移16位后再与自身做异或操作，简单来说就是高位和低位异或，最大限度的加大hash值的随机性，但是低位又保留了高位的部分特征。最后通过<code>(length - 1) &amp; hash</code>计算元素在bucket中的位置。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="few3"><ol class="linenums"><li class="L0"><code><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> h</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln">h </span><span class="pun">=</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">hashCode</span><span class="pun">())</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">(</span><span class="pln">h </span><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="lit">16</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="tm1d" id="2-getnode">(2) getNode</h2><p data-anchor-id="l6tq">此方法是最常用的操作，通过key取value，如果有冲突会继续做链表或红黑树的查找。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="hqot"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">final</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">.</span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> getNode</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">HashMap</span><span class="pun">.</span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;[]</span><span class="pln"> tab</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="typ">HashMap</span><span class="pun">.</span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> first</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">    K k</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="com">//三重判断：bucket初始化状态，有无元素，key的hash是否映射到键值对。</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">first </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">[(</span><span class="pln">n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> hash</span><span class="pun">])</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="com">//1.映射到的第一个键值对hash和目标key相同</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="com">//2.键值对的key和目标key相同或等价</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="com">//满足上述两个条件说明这个键值对就是需要查找的，返回这个键值对。</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">first</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> first</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">))))</span></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> first</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="com">//当该key有冲突时，需要继续查找。</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> first</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"><span class="pln">            </span><span class="com">//上面说到，冲突超过8时，链表结构会转为红黑树结构，此处时红黑树的查找。</span></code></li><li class="L0"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">first </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">.</span><span class="typ">TreeNode</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L1"><code class="language-java"><span class="pln">                </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">((</span><span class="typ">HashMap</span><span class="pun">.</span><span class="typ">TreeNode</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;)</span><span class="pln"> first</span><span class="pun">).</span><span class="pln">getTreeNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="com">//循环遍历查找</span></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-java"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span></code></li><li class="L6"><code class="language-java"><span class="pln">                        </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">))))</span></code></li><li class="L7"><code class="language-java"><span class="pln">                    </span><span class="kwd">return</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="tdna" id="3-put">(3) put</h2><p data-anchor-id="x2ch">此方法用于存放键值对元素，具体会调用putVal方法。onlyIfAbsent：是否替换键对应的值。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="hu50"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">final</span><span class="pln"> V putVal</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">,</span><span class="pln"> K key</span><span class="pun">,</span><span class="pln"> V value</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> onlyIfAbsent</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> evict</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;[]</span><span class="pln"> tab</span><span class="pun">;</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> p</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="com">//判断bucket是否需要初始化，这是一种懒加载的策略，HashMap在第一次put操作时才会初始化bucket。</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L5"><code class="language-java"><span class="pln">        n </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> resize</span><span class="pun">()).</span><span class="pln">length</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="com">//如果目标元素映射到的位置没有元素，则在该处存入。</span></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">[</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> hash</span><span class="pun">])</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L9"><code class="language-java"><span class="pln">        tab</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> newNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span></code></li><li class="L0"><code class="language-java"></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="com">//如果有，则查找元素再替换value对象。</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e</span><span class="pun">;</span><span class="pln"> K k</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="com">//判断bucket该位置的第一个元素是否为查找的元素</span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span></code></li><li class="L7"><code class="language-java"><span class="pln">            </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">))))</span></code></li><li class="L8"><code class="language-java"><span class="pln">            e </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="com">//如果node已经是红黑树结构，进行插入操作。</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">TreeNode</span><span class="pun">)</span></code></li><li class="L2"><code class="language-java"><span class="pln">            e </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((</span><span class="typ">TreeNode</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;)</span><span class="pln">p</span><span class="pun">).</span><span class="pln">putTreeVal</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> tab</span><span class="pun">,</span><span class="pln"> hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">);</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="com">//循环，并用binCount计数。</span></code></li><li class="L6"><code class="language-java"><span class="pln">            </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> binCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">binCount</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">                </span><span class="com">//如果遍历到表尾还没查找到，直接插入到尾部。</span></code></li><li class="L9"><code class="language-java"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-java"><span class="pln">                    p</span><span class="pun">.</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> newNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">                    </span><span class="com">//如果链表长度是否大于8，则将链表结构转为红黑树。</span></code></li><li class="L3"><code class="language-java"><span class="pln">                    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">binCount </span><span class="pun">&gt;=</span><span class="pln"> TREEIFY_THRESHOLD </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="com">// -1 for 1st</span></code></li><li class="L4"><code class="language-java"><span class="pln">                        treeifyBin</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">,</span><span class="pln"> hash</span><span class="pun">);</span></code></li><li class="L5"><code class="language-java"><span class="pln">                    </span><span class="kwd">break</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">                </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">                </span><span class="com">//如果查找到，跳出循环</span></code></li><li class="L9"><code class="language-java"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span></code></li><li class="L0"><code class="language-java"><span class="pln">                    </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">))))</span></code></li><li class="L1"><code class="language-java"><span class="pln">                    </span><span class="kwd">break</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">                p </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="com">//存在key，将已有的value替换，并返回已有的value</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">// existing mapping for key</span></code></li><li class="L8"><code class="language-java"><span class="pln">            V oldValue </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">;</span></code></li><li class="L9"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">onlyIfAbsent </span><span class="pun">||</span><span class="pln"> oldValue </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L0"><code class="language-java"><span class="pln">                e</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> value</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">            afterNodeAccess</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> oldValue</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="pun">++</span><span class="pln">modCount</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="com">//如果此时元素数量大于阀值，进行resize()操作。</span></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(++</span><span class="pln">size </span><span class="pun">&gt;</span><span class="pln"> threshold</span><span class="pun">)</span></code></li><li class="L9"><code class="language-java"><span class="pln">        resize</span><span class="pun">();</span></code></li><li class="L0"><code class="language-java"><span class="pln">    afterNodeInsertion</span><span class="pun">(</span><span class="pln">evict</span><span class="pun">);</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="ti0a" id="4-resize">(4) resize</h2><p data-anchor-id="tzk3">当集合中元素数量超过threshold时，会进行容量调整操作。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="97lh"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">final</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;[]</span><span class="pln"> resize</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;[]</span><span class="pln"> oldTab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> oldCap </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldTab </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> oldTab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="com">// 数组长度</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> oldThr </span><span class="pun">=</span><span class="pln"> threshold</span><span class="pun">;</span><span class="com">// 临界值</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> newCap</span><span class="pun">,</span><span class="pln"> newThr </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldCap </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="com">// 扩容</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldCap </span><span class="pun">&gt;=</span><span class="pln"> MAXIMUM_CAPACITY</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="com">// 原数组长度大于最大容量，则将threshold设为Integer.MAX_VALUE。</span></code></li><li class="L9"><code class="language-java"><span class="pln">            </span><span class="com">// 接近MAXIMUM_CAPACITY的两倍</span></code></li><li class="L0"><code class="language-java"><span class="pln">            threshold </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">.</span><span class="pln">MAX_VALUE</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> oldTab</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">newCap </span><span class="pun">=</span><span class="pln"> oldCap </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> MAXIMUM_CAPACITY </span><span class="pun">&amp;&amp;</span><span class="pln"> oldCap </span><span class="pun">&gt;=</span><span class="pln"> DEFAULT_INITIAL_CAPACITY</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="com">// 新数组长度 是原来的2倍，</span></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="com">// 临界值也扩大为原来2倍</span></code></li><li class="L5"><code class="language-java"><span class="pln">            newThr </span><span class="pun">=</span><span class="pln"> oldThr </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldThr </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="com">// 如果原来的thredshold大于0则将容量设为原来的thredshold</span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="com">// 在第一次带参数初始化时候会有这种情况</span></code></li><li class="L0"><code class="language-java"><span class="pln">        newCap </span><span class="pun">=</span><span class="pln"> oldThr</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="com">// 在默认无参数初始化会有这种情况</span></code></li><li class="L3"><code class="language-java"><span class="pln">        newCap </span><span class="pun">=</span><span class="pln"> DEFAULT_INITIAL_CAPACITY</span><span class="pun">;</span><span class="com">// 16</span></code></li><li class="L4"><code class="language-java"><span class="pln">        newThr </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">DEFAULT_LOAD_FACTOR </span><span class="pun">*</span><span class="pln"> DEFAULT_INITIAL_CAPACITY</span><span class="pun">);</span><span class="com">// 0.75*16=12</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newThr </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="com">// 如果新 的容量 ==0</span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="kwd">float</span><span class="pln"> ft </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">float</span><span class="pun">)</span><span class="pln"> newCap </span><span class="pun">*</span><span class="pln"> loadFactor</span><span class="pun">;</span><span class="com">// loadFactor 哈希加载因子 默认0.75,可在初始化时传入,16*0.75=12 可以放12个键值对</span></code></li><li class="L9"><code class="language-java"><span class="pln">        newThr </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newCap </span><span class="pun">&lt;</span><span class="pln"> MAXIMUM_CAPACITY </span><span class="pun">&amp;&amp;</span><span class="pln"> ft </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">float</span><span class="pun">)</span><span class="pln"> MAXIMUM_CAPACITY </span><span class="pun">?</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> ft </span><span class="pun">:</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">.</span><span class="pln">MAX_VALUE</span><span class="pun">);</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L1"><code class="language-java"><span class="pln">    threshold </span><span class="pun">=</span><span class="pln"> newThr</span><span class="pun">;</span><span class="com">// 将临界值设置为新临界值</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="lit">@SuppressWarnings</span><span class="pun">({</span><span class="pln"> </span><span class="str">"rawtypes"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"unchecked"</span><span class="pln"> </span><span class="pun">})</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="com">// 扩容</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;[]</span><span class="pln"> newTab </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;[])</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">[</span><span class="pln">newCap</span><span class="pun">];</span></code></li><li class="L5"><code class="language-java"><span class="pln">    table </span><span class="pun">=</span><span class="pln"> newTab</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="com">// 如果原来的table有数据，则将数据复制到新的table中</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldTab </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="com">// 根据容量进行循环整个数组，将非空元素进行复制</span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;</span><span class="pln"> oldCap</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-java"><span class="pln">            </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">            </span><span class="com">// 获取数组的第j个元素</span></code></li><li class="L2"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> oldTab</span><span class="pun">[</span><span class="pln">j</span><span class="pun">])</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">                oldTab</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">                </span><span class="com">// 如果链表只有一个，则进行直接赋值</span></code></li><li class="L5"><code class="language-java"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">next </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">                    </span><span class="com">// e.hash &amp; (newCap - 1) 确定元素存放位置</span></code></li><li class="L7"><code class="language-java"><span class="pln">                    newTab</span><span class="pun">[</span><span class="pln">e</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newCap </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">                </span><span class="com">//  此处省略红黑树</span></code></li><li class="L9"><code class="language-java"><span class="pln">                </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-java"><span class="pln">                    </span><span class="com">// 进行链表复制</span></code></li><li class="L1"><code class="language-java"><span class="pln">                    </span><span class="com">// 方法比较特殊： 它并没有重新计算元素在数组中的位置</span></code></li><li class="L2"><code class="language-java"><span class="pln">                    </span><span class="com">// 而是采用了 原始位置加原数组长度的方法计算得到位置</span></code></li><li class="L3"><code class="language-java"><span class="pln">                    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> loHead </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> loTail </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">                    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> hiHead </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> hiTail </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">                    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> next</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">                    </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="language-java"><span class="pln">                        next </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">                        </span><span class="com">// 注意：不是(e.hash &amp; (oldCap-1));而是(e.hash &amp; oldCap)</span></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="pln">                        </span><span class="com">// (e.hash &amp; oldCap) 得到的是 元素的在数组中的位置是否需要移动,示例如下</span></code></li><li class="L1"><code class="language-java"><span class="pln">                        </span><span class="com">// 示例1：</span></code></li><li class="L2"><code class="language-java"><span class="pln">                        </span><span class="com">// e.hash=10 0000 1010</span></code></li><li class="L3"><code class="language-java"><span class="pln">                        </span><span class="com">// oldCap=16 0001 0000</span></code></li><li class="L4"><code class="language-java"><span class="pln">                        </span><span class="com">//   &amp;   =0  0000 0000       比较高位的第一位 0</span></code></li><li class="L5"><code class="language-java"><span class="pln">                        </span><span class="com">//结论：元素位置在扩容后数组中的位置没有发生改变</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">                        </span><span class="com">// 示例2：</span></code></li><li class="L8"><code class="language-java"><span class="pln">                        </span><span class="com">// e.hash=17 0001 0001</span></code></li><li class="L9"><code class="language-java"><span class="pln">                        </span><span class="com">// oldCap=16 0001 0000</span></code></li><li class="L0"><code class="language-java"><span class="pln">                        </span><span class="com">//   &amp;   =1  0001 0000      比较高位的第一位   1</span></code></li><li class="L1"><code class="language-java"><span class="pln">                        </span><span class="com">//结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度</span></code></li><li class="L2"><code class="language-java"></code></li><li class="L3"><code class="language-java"><span class="pln">                        </span><span class="com">// (e.hash &amp; (oldCap-1)) 得到的是下标位置,示例如下</span></code></li><li class="L4"><code class="language-java"><span class="pln">                        </span><span class="com">//   e.hash=10 0000 1010</span></code></li><li class="L5"><code class="language-java"><span class="pln">                        </span><span class="com">// oldCap-1=15 0000 1111</span></code></li><li class="L6"><code class="language-java"><span class="pln">                        </span><span class="com">//      &amp;  =10 0000 1010</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">                        </span><span class="com">//   e.hash=17 0001 0001</span></code></li><li class="L9"><code class="language-java"><span class="pln">                        </span><span class="com">// oldCap-1=15 0000 1111</span></code></li><li class="L0"><code class="language-java"><span class="pln">                        </span><span class="com">//      &amp;  =1  0000 0001</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">                        </span><span class="com">//新下标位置</span></code></li><li class="L3"><code class="language-java"><span class="pln">                        </span><span class="com">//   e.hash=17 0001 0001</span></code></li><li class="L4"><code class="language-java"><span class="pln">                        </span><span class="com">// newCap-1=31 0001 1111    newCap=32</span></code></li><li class="L5"><code class="language-java"><span class="pln">                        </span><span class="com">//      &amp;  =17 0001 0001    1+oldCap = 1+16</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">                        </span><span class="com">//元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</span></code></li><li class="L8"><code class="language-java"><span class="pln">                        </span><span class="com">// 0000 0001-&gt;0001 0001</span></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="pln">                        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">&amp;</span><span class="pln"> oldCap</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">                            </span><span class="com">// 如果原元素位置没有发生变化</span></code></li><li class="L2"><code class="language-java"><span class="pln">                            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">loTail </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L3"><code class="language-java"><span class="pln">                                loHead </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span><span class="com">// 确定首元素</span></code></li><li class="L4"><code class="language-java"><span class="pln">                            </span><span class="com">// 第一次进入时     e   -&gt; aa  ; loHead-&gt; aa</span></code></li><li class="L5"><code class="language-java"><span class="pln">                            </span><span class="kwd">else</span></code></li><li class="L6"><code class="language-java"><span class="pln">                                loTail</span><span class="pun">.</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pln">                            </span><span class="com">//第二次进入时        loTail-&gt; aa  ;    e  -&gt; bb ;  loTail.next -&gt; bb;而loHead和loTail是指向同一块内存的，所以loHead.next 地址为 bb  </span></code></li><li class="L8"><code class="language-java"><span class="pln">                            </span><span class="com">//第三次进入时        loTail-&gt; bb  ;    e  -&gt; cc ;  loTail.next 地址为 cc;loHead.next.next = cc</span></code></li><li class="L9"><code class="language-java"><span class="pln">                            loTail </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L0"><code class="language-java"><span class="pln">                            </span><span class="com">// 第一次进入时         e   -&gt; aa  ; loTail-&gt; aa loTail指向了和  loHead相同的内存空间</span></code></li><li class="L1"><code class="language-java"><span class="pln">                            </span><span class="com">// 第二次进入时               e   -&gt; bb  ; loTail-&gt; bb loTail指向了和  loTail.next（loHead.next）相同的内存空间   loTail=loTail.next</span></code></li><li class="L2"><code class="language-java"><span class="pln">                            </span><span class="com">// 第三次进入时               e   -&gt; cc  ; loTail-&gt; cc loTail指向了和  loTail.next(loHead.next.next)相同的内存</span></code></li><li class="L3"><code class="language-java"><span class="pln">                        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"><span class="pln">                            </span><span class="com">//与上面同理</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln">                            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hiTail </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L7"><code class="language-java"><span class="pln">                                hiHead </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">                            </span><span class="kwd">else</span></code></li><li class="L9"><code class="language-java"><span class="pln">                                hiTail</span><span class="pun">.</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L0"><code class="language-java"><span class="pln">                            hiTail </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">                        </span><span class="pun">}</span></code></li><li class="L2"><code class="language-java"><span class="pln">                    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="com">//这一块就是 旧链表迁移新链表</span></code></li><li class="L3"><code class="language-java"><span class="pln">                    </span><span class="com">//总结：1.8中 旧链表迁移新链表    链表元素相对位置没有变化; 实际是对对象的内存地址进行操作 </span></code></li><li class="L4"><code class="language-java"><span class="pln">                    </span><span class="com">//在1.7中  旧链表迁移新链表        如果在新表的数组索引位置相同，则链表元素会倒置</span></code></li><li class="L5"><code class="language-java"><span class="pln">                    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">loTail </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code class="language-java"><span class="pln">                        loTail</span><span class="pun">.</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="com">// 将链表的尾节点 的next 设置为空</span></code></li><li class="L7"><code class="language-java"><span class="pln">                        newTab</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> loHead</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">                    </span><span class="pun">}</span></code></li><li class="L9"><code class="language-java"><span class="pln">                    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hiTail </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-java"><span class="pln">                        hiTail</span><span class="pun">.</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="com">// 将链表的尾节点 的next 设置为空</span></code></li><li class="L1"><code class="language-java"><span class="pln">                        newTab</span><span class="pun">[</span><span class="pln">j </span><span class="pun">+</span><span class="pln"> oldCap</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> hiHead</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">                    </span><span class="pun">}</span></code></li><li class="L3"><code class="language-java"><span class="pln">                </span><span class="pun">}</span></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> newTab</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="yjli" id="5-remove">(5) remove</h2><p data-anchor-id="qpti">删除map中的指定键值对，先查找到该结点，然后分不同的情况来删除。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7rlg"><ol class="linenums"><li class="L0"><code class="language-java"></code></li><li class="L1"><code class="language-java"><span class="com">//具体调用方法时removeNode</span></code></li><li class="L2"><code class="language-java"><span class="kwd">public</span><span class="pln"> V remove</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> removeNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">key</span><span class="pun">),</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">))</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pun">}</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="kwd">final</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> removeNode</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> value</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> matchValue</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> movable</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;[]</span><span class="pln"> tab</span><span class="pun">;</span><span class="pln"> </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> p</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="com">//获取bucket和hash映射的首元素。</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="pun">(</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">[</span><span class="pln">index </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> hash</span><span class="pun">])</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">;</span><span class="pln"> K k</span><span class="pun">;</span><span class="pln"> V v</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="com">//下面逻辑和getNode类似，通过key的equals方法找到具体的结点</span></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span></code></li><li class="L1"><code class="language-java"><span class="pln">            </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">))))</span></code></li><li class="L2"><code class="language-java"><span class="pln">            node </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">TreeNode</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">                node </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((</span><span class="typ">TreeNode</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;)</span><span class="pln">p</span><span class="pun">).</span><span class="pln">getTreeNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">);</span></code></li><li class="L7"><code class="language-java"><span class="pln">            </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"><span class="pln">                </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code class="language-java"><span class="pln">                    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span></code></li><li class="L0"><code class="language-java"><span class="pln">                        </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span></code></li><li class="L1"><code class="language-java"><span class="pln">                         </span><span class="pun">(</span><span class="pln">key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">))))</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-java"><span class="pln">                        node </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">                        </span><span class="kwd">break</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">                    </span><span class="pun">}</span></code></li><li class="L5"><code class="language-java"><span class="pln">                    p </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">                </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span></code></li><li class="L7"><code class="language-java"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L9"><code class="language-java"></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="com">//判断是否找到对应的结点</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">matchValue </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> value </span><span class="pun">||</span></code></li><li class="L2"><code class="language-java"><span class="pln">                             </span><span class="pun">(</span><span class="pln">value </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> value</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">v</span><span class="pun">))))</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="com">//红黑树结构删除操作</span></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">TreeNode</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">                </span><span class="pun">((</span><span class="typ">TreeNode</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;)</span><span class="pln">node</span><span class="pun">).</span><span class="pln">removeTreeNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> tab</span><span class="pun">,</span><span class="pln"> movable</span><span class="pun">);</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="com">//如果是表头元素，直接将该位置指向下一个元素</span></code></li><li class="L9"><code class="language-java"><span class="pln">            </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node </span><span class="pun">==</span><span class="pln"> p</span><span class="pun">)</span></code></li><li class="L0"><code class="language-java"><span class="pln">                tab</span><span class="pun">[</span><span class="pln">index</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">            </span><span class="kwd">else</span></code></li><li class="L2"><code class="language-java"><span class="pln">                p</span><span class="pun">.</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="com">//修改变量</span></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="pun">++</span><span class="pln">modCount</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">            </span><span class="pun">--</span><span class="pln">size</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pln">            afterNodeRemoval</span><span class="pun">(</span><span class="pln">node</span><span class="pun">);</span></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">;</span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="oepp" id="6-clear">(6) clear</h2><p data-anchor-id="zv09">清空集合内所有的元素，直接循环遍历将bucket每个位置上都重置为null。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="v22k"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> clear</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;[]</span><span class="pln"> tab</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    modCount</span><span class="pun">++;</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> size </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"><span class="pln">        size </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> tab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">            tab</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="r0x8" id="7-containsvalue">(7) containsValue</h2><p data-anchor-id="y8nf">判断bucket中是否存在指定value的键值对元素，逻辑比较简单，直接遍历整个bucket，再对每个位置上遍历所有冲突的元素。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="6x3k"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> containsValue</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;[]</span><span class="pln"> tab</span><span class="pun">;</span><span class="pln"> V v</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> size </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> tab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln"> e </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-java"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">v </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> value </span><span class="pun">||</span></code></li><li class="L6"><code class="language-java"><span class="pln">                    </span><span class="pun">(</span><span class="pln">value </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> value</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)))</span></code></li><li class="L7"><code class="language-java"><span class="pln">                    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="6nyt" id="8-keyset">(8) keySet</h2><p data-anchor-id="rjkt">此方法用于返回所有key的一个set对象，但是这个set中不包含有key的数据，而是直接操作HashMap中的数据，实现类是在HashMap中定义的一个内部类。</p><p data-anchor-id="d0u9">另外方法values和entrySet都是如此，实现一个内部类对象，然后提供一系列方法进行操作。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bn4o"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">&gt;</span><span class="pln"> keySet</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">&gt;</span><span class="pln"> ks </span><span class="pun">=</span><span class="pln"> keySet</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ks </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">        ks </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">KeySet</span><span class="pun">();</span></code></li><li class="L4"><code class="language-java"><span class="pln">        keySet </span><span class="pun">=</span><span class="pln"> ks</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> ks</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pun">}</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"><span class="com">//keySet具体实现类，一系列操作都是直接对HashMap上进行。</span></code></li><li class="L0"><code class="language-java"><span class="kwd">final</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">KeySet</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AbstractSet</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="com">//元素数量</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> size</span><span class="pun">()</span><span class="pln">                 </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> size</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span></code></li><li class="L4"><code class="language-java"></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="com">//清空</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> clear</span><span class="pun">()</span><span class="pln">               </span><span class="pun">{</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">.</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">clear</span><span class="pun">();</span><span class="pln"> </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="com">//迭代器</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Iterator</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">&gt;</span><span class="pln"> iterator</span><span class="pun">()</span><span class="pln">     </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">KeyIterator</span><span class="pun">();</span><span class="pln"> </span><span class="pun">}</span></code></li><li class="L0"><code class="language-java"></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="com">//是否含有某个key</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> contains</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> o</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> containsKey</span><span class="pun">(</span><span class="pln">o</span><span class="pun">);</span><span class="pln"> </span><span class="pun">}</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="com">//删除指定key</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> remove</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> removeNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">key</span><span class="pun">),</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-java"></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="com">//java8的stream流迭代</span></code></li><li class="L0"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Spliterator</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">&gt;</span><span class="pln"> spliterator</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">KeySpliterator</span><span class="pun">&lt;&gt;(</span><span class="typ">HashMap</span><span class="pun">.</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> forEach</span><span class="pun">(</span><span class="typ">Consumer</span><span class="pun">&lt;?</span><span class="pln"> </span><span class="kwd">super</span><span class="pln"> K</span><span class="pun">&gt;</span><span class="pln"> action</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;[]</span><span class="pln"> tab</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">action </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">NullPointerException</span><span class="pun">();</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">size </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tab </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="kwd">int</span><span class="pln"> mc </span><span class="pun">=</span><span class="pln"> modCount</span><span class="pun">;</span></code></li><li class="L9"><code class="language-java"><span class="pln">            </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> tab</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-java"><span class="pln">                </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> tab</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln"> e </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span></code></li><li class="L1"><code class="language-java"><span class="pln">                    action</span><span class="pun">.</span><span class="pln">accept</span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">key</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">modCount </span><span class="pun">!=</span><span class="pln"> mc</span><span class="pun">)</span></code></li><li class="L4"><code class="language-java"><span class="pln">                </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ConcurrentModificationException</span><span class="pun">();</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="c0mn" id="9-replace">(9) replace</h2><p data-anchor-id="r2cc">顾名思义，此方法是用指定键值对替换原有的，有两种实现方法。</p><p data-anchor-id="7fjw">第一种需要指定key和value，通过key查找，然后替换原有的value值。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="n7zs"><ol class="linenums"><li class="L0"><code class="language-java"><span class="lit">@Override</span></code></li><li class="L1"><code class="language-java"><span class="kwd">public</span><span class="pln"> V replace</span><span class="pun">(</span><span class="pln">K key</span><span class="pun">,</span><span class="pln"> V value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> getNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">key</span><span class="pun">),</span><span class="pln"> key</span><span class="pun">))</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"><span class="pln">        V oldValue </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">        e</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> value</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">        afterNodeAccess</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> oldValue</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L0"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="k4y8">第二种需要指定两个value，整个键值对完全匹配才会替换value、</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ki3v"><ol class="linenums"><li class="L0"><code class="language-java"><span class="lit">@Override</span></code></li><li class="L1"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> replace</span><span class="pun">(</span><span class="pln">K key</span><span class="pun">,</span><span class="pln"> V oldValue</span><span class="pun">,</span><span class="pln"> V newValue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="typ">Node</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e</span><span class="pun">;</span><span class="pln"> V v</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">e </span><span class="pun">=</span><span class="pln"> getNode</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">key</span><span class="pun">),</span><span class="pln"> key</span><span class="pun">))</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="pun">((</span><span class="pln">v </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> oldValue </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> v</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">oldValue</span><span class="pun">))))</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-java"><span class="pln">        e</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> newValue</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">        afterNodeAccess</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L9"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span></code></li><li class="L0"><code class="language-java"><span class="pun">}</span></code></li></ol></pre></div>
</body>
</html>